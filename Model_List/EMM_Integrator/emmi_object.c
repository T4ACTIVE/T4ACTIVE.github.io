/**
 * Generated by anjay_codegen.py on 2017-10-17 15:45:32
 *
 * LwM2M Object: EMM-Integrator
 * ID: 25010, URN: urn:oma:lwm2m:x:25010:1, Optional, Multiple
 *
 * This object integrates all the components that belong to the physical Energy Management Module Platform as Object Links.
 */
#include <assert.h>
#include <stdbool.h>

#include <anjay/anjay.h>
#include <avsystem/commons/defs.h>
#include <avsystem/commons/list.h>

/**
 * Device: R, Single, Mandatory
 * type: string, range: N/A, unit: N/A
 * The device description of the EMM.
 */
#define RID_DEVICE 20170

/**
 * LogControl: , Multiple, Mandatory
 * type: string, range: N/A, unit: N/A
 * Sensor log control link.
 */
#define RID_LOGCONTROL 20171

/**
 * DeviceBind: , Multiple, Mandatory
 * type: string, range: N/A, unit: N/A
 * Binding the EMM to a physical device it measures.
 */
#define RID_DEVICEBIND 20172

/**
 * VoltageSensor: , Multiple, Mandatory
 * type: string, range: N/A, unit: N/A
 * The integrated voltage sensor.
 */
#define RID_VOLTAGESENSOR 20173

/**
 * CurrentSensor: , Multiple, Mandatory
 * type: string, range: N/A, unit: N/A
 * The integrated current sensor.
 */
#define RID_CURRENTSENSOR 20174

/**
 * PowerSensor: , Multiple, Mandatory
 * type: string, range: N/A, unit: N/A
 * The integrated power sensor.
 */
#define RID_POWERSENSOR 20175

typedef struct emm_integrator_instance_struct {
    anjay_iid_t iid;

    // TODO: instance state
} emm_integrator_instance_t;

typedef struct emm_integrator_struct {
    const anjay_dm_object_def_t *def;
    AVS_LIST(emm_integrator_instance_t) instances;

    // TODO: object state
} emm_integrator_t;

static inline emm_integrator_t *
get_obj(const anjay_dm_object_def_t *const *obj_ptr) {
    assert(obj_ptr);
    return AVS_CONTAINER_OF(obj_ptr, emm_integrator_t, def);
}

static emm_integrator_instance_t *
find_instance(const emm_integrator_t *obj,
              anjay_iid_t iid) {
    AVS_LIST(emm_integrator_instance_t) it;
    AVS_LIST_FOREACH(it, obj->instances) {
        if (it->iid == iid) {
            return it;
        } else if (it->iid > iid) {
            break;
        }
    }

    return NULL;
}

static int instance_present(anjay_t *anjay,
                            const anjay_dm_object_def_t *const *obj_ptr,
                            anjay_iid_t iid) {
    (void)anjay;
    return find_instance(get_obj(obj_ptr), iid) != NULL;
}

static int instance_it(anjay_t *anjay,
                       const anjay_dm_object_def_t *const *obj_ptr,
                       anjay_iid_t *out,
                       void **cookie) {
    (void)anjay;

    AVS_LIST(emm_integrator_instance_t) curr = (AVS_LIST(emm_integrator_instance_t))*cookie;
    if (!curr) {
        curr = get_obj(obj_ptr)->instances;
    } else {
        curr = AVS_LIST_NEXT(curr);
    }

    *out = curr ? curr->iid : ANJAY_IID_INVALID;
    *cookie = curr;
    return 0;
}

static anjay_iid_t get_new_iid(AVS_LIST(emm_integrator_instance_t) instances) {
    anjay_iid_t iid = 1;
    AVS_LIST(emm_integrator_instance_t) it;
    AVS_LIST_FOREACH(it, instances) {
        if (it->iid == iid) {
            ++iid;
        } else if (it->iid > iid) {
            break;
        }
    }
    return iid;
}

static int init_instance(emm_integrator_instance_t *inst,
                         anjay_iid_t iid) {
    assert(iid != ANJAY_IID_INVALID);

    inst->iid = iid;
    // TODO: instance init

    // TODO: return 0 on success, negative value on failure
    return 0;
}

static void release_instance(emm_integrator_instance_t *inst) {
    // TODO: instance cleanup
    (void) inst;
}

static int instance_create(anjay_t *anjay,
                           const anjay_dm_object_def_t *const *obj_ptr,
                           anjay_iid_t *inout_iid,
                           anjay_ssid_t ssid) {
    (void) anjay; (void) ssid;
    emm_integrator_t *obj = get_obj(obj_ptr);
    assert(obj);

    AVS_LIST(emm_integrator_instance_t) created = AVS_LIST_NEW_ELEMENT(emm_integrator_instance_t);
    if (!created) {
        return ANJAY_ERR_INTERNAL;
    }

    if (*inout_iid == ANJAY_IID_INVALID) {
        *inout_iid = get_new_iid(obj->instances);
    }

    int result = ANJAY_ERR_INTERNAL;
    if (*inout_iid == ANJAY_IID_INVALID
            || (result == init_instance(created, *inout_iid))) {
        AVS_LIST_CLEAR(&created);
        return result;
    }

    AVS_LIST(emm_integrator_instance_t) *ptr;
    AVS_LIST_FOREACH_PTR(ptr, &obj->instances) {
        if ((*ptr)->iid > created->iid) {
            break;
        }
    }

    AVS_LIST_INSERT(ptr, created);
    return 0;
}

static int instance_remove(anjay_t *anjay,
                           const anjay_dm_object_def_t *const *obj_ptr,
                           anjay_iid_t iid) {
    (void)anjay;
    emm_integrator_t *obj = get_obj(obj_ptr);
    assert(obj);

    AVS_LIST(emm_integrator_instance_t) *it;
    AVS_LIST_FOREACH_PTR(it, &obj->instances) {
        if ((*it)->iid == iid) {
            release_instance(*it);
            AVS_LIST_DELETE(it);
            return 0;
        } else if ((*it)->iid > iid) {
            break;
        }
    }

    assert(0);
    return ANJAY_ERR_NOT_FOUND;
}

static int instance_reset(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid) {
    (void) anjay;

    emm_integrator_instance_t *inst = find_instance(get_obj(obj_ptr), iid);
    assert(inst);

    // TODO: instance reset
    return 0;
}

static int resource_read(anjay_t *anjay,
                         const anjay_dm_object_def_t *const *obj_ptr,
                         anjay_iid_t iid,
                         anjay_rid_t rid,
                         anjay_output_ctx_t *ctx) {
    (void)anjay;

    emm_integrator_t *obj = get_obj(obj_ptr);
    assert(obj);
    emm_integrator_instance_t *inst = find_instance(obj, iid);
    assert(inst);

    switch (rid) {
    case RID_DEVICE:
        return anjay_ret_string(ctx, ""); // TODO

    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

static int resource_dim(anjay_t *anjay,
                        const anjay_dm_object_def_t *const *obj_ptr,
                        anjay_iid_t iid,
                        anjay_rid_t rid) {
    (void) anjay;

    emm_integrator_t *obj = get_obj(obj_ptr);
    assert(obj);
    emm_integrator_instance_t *inst = find_instance(obj, iid);
    assert(inst);

    switch (rid) {
    case RID_LOGCONTROL:
        return 1; // TODO

    case RID_DEVICEBIND:
        return 1; // TODO

    case RID_VOLTAGESENSOR:
        return 1; // TODO

    case RID_CURRENTSENSOR:
        return 1; // TODO

    case RID_POWERSENSOR:
        return 1; // TODO

    default:
        return ANJAY_DM_DIM_INVALID;
    }
}

static const anjay_dm_object_def_t OBJ_DEF = {
    .oid = 25010,
    .supported_rids = ANJAY_DM_SUPPORTED_RIDS(
                RID_DEVICE,
                RID_LOGCONTROL,
                RID_DEVICEBIND,
                RID_VOLTAGESENSOR,
                RID_CURRENTSENSOR,
                RID_POWERSENSOR,
            ),
    .handlers = {
        .instance_it = instance_it,
        .instance_present = instance_present,
        .instance_create = instance_create,
        .instance_remove = instance_remove,
        .instance_reset = instance_reset,

        .resource_present = anjay_dm_resource_present_TRUE,
        .resource_read = resource_read,
        .resource_dim = resource_dim,

        // TODO: implement these if transactional write/create is required
        .transaction_begin = anjay_dm_transaction_NOOP,
        .transaction_validate = anjay_dm_transaction_NOOP,
        .transaction_commit = anjay_dm_transaction_NOOP,
        .transaction_rollback = anjay_dm_transaction_NOOP,
    }
};

const anjay_dm_object_def_t **emm_integrator_object_create(void) {
    emm_integrator_t *obj = (emm_integrator_t *)
            calloc(1, sizeof(emm_integrator_t));
    if (!obj) {
        return NULL;
    }
    obj->def = &OBJ_DEF;

    // TODO: object init

    return &obj->def;
}

void emm_integrator_object_release(const anjay_dm_object_def_t **def) {
    if (def) {
        emm_integrator_t *obj = get_obj(def);
        AVS_LIST_CLEAR(&obj->instances) {
            release_instance(obj->instances);
        }

        // TODO: object cleanup

        free(obj);
    }
}
